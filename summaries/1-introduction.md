# Lesson 1: Introduction to Programming!
In this lesson we covered a bit of an introduction of computing, the basic setup of your development environment, and saw a basic Hello World program. I'll provide a list of places where you can read up further on the subjects (optional) and a brief summary of the key points.

## Computers and machine code
- Numbers can be written in various "bases". The one you're used to is base 10 ("decimal"). Computers use base 2 (binary). Other common ones you might encounter during programming are base 8 ("octal") and base 16 ("hexadecimal").
- A **bit** is the lowest unit of computing, and it just means "a single **b**inary dig**it**". A byte is made up of 8 bits.
- "Machine code" - which to you would look like an endless sequence of 0s and 1s - is actually just a sequence of numbers encoded in binary; that way, the "binary stream" can be converted to specific numbers. Generally speaking, these numbers are treated by the CPU as instructions (or *opcodes*) of fixed size, with each number corresponding to a different instruction, or as flat numbers, or as memory addresses (meaning: specific locations in memory).
- The Assembly language is what's commonly used by low-level programmers to manipulate these instructions in a way that is readable to them, but still close to the way the machine "thinks".

## Languages (and Java, specifically)
- Programming languages are a "middle ground" between you and the computer which you can use to give instructions to the machine without straying too far from your own way of thinking.
- Languages are commonly divided in "compiled" and "interpreted". Compiled languages (examples: C, C++, Rust, Go) make use of a *compiler*, a special program that converts your program fully into machine code, which can then be executed. Interpreted anguages (examples: Python, JavaScript) make use of an *interpreter*, a special program that reads, converts and executes the program line by line rather than converting it all beforehand. Compiled languages are generally faster, as converting it all at once allows the compiler to do severe optimisations to make your code faster.
- Java is a bit of both. It's *compiled* to *target* a virtual machine (the **JVM**, standing for *Java Virtual Machine*) rather than your computer's CPU. The JVM then *interprets* your program as it goes, translating its machine code to your computer's machine code. Although good code is always more performing than bad code, Java trades performance for portability: because it runs in a virtual machine, your Java code will run on any computer system supported by the JVM with no (or minimal) alterations.
- Most *general-purpose* (meaning: usable for any kind of program) languages are "multi-paradigm", meaning that they support various "types" of programming - we'll see in the future exactly what it means. Java is technically multi-paradigm as well, according to Wikipedia, but if you ask me it's strictly Object-Oriented - meaning that it enforces a style of programming based on "objects", which you can think of as containers of code with shared behavior. I understand it's unclear, but we'll see in a future lesson more in detail.

## Java, JVM, JDK
- Why learn Java? Key advantages: it's easily portable to other platforms, it teaches you Object Oriented Programming whether you like it or not, and becase of its portability it's very commonly used as *backend* software for websites. And it's the language of block game. If you were to look for a way to do Java at a professional level, you probably wouldn't struggle to find it. There's always demand for fresh meat in enterprise-grade software.
- As you may have guessed, since the JVM is a full fledged virtual machine, it's entirely possible for third party languages to "target" it and compile to it. The big three that do this are **Scala**, **Kotlin** and **Groovy**. Scala and Kotlin both aim to fix many design flaws within JavaÂ¹; Groovy was an attempt to make Java's syntax more "freeform", resembling Python, with horrid results.
- We use Java 8 in the course, even if the current version is 20, for multiple reasons. First, Java 8 is a subset of Java 20, meaning that all or near-all Java 8 code is perfectly valid - if a bit ugly - in Java 20. Second, it's the one Minecraft uses up until about 1.17, so for modding that's what you want to use. Third, Java 8 is an LTS (Long Term Support) version, which is gonna stay suported for another 7 years (which means that enterprise Java will probably not move away from Java 8 for about double that amount).
- The JDK contains a few things: the JVM for that version, a set of utilities for Java programmers (including the compiler, `javac`), and the Java Standard Library. A Library is, put simply, a program that doesn't do anything on its own, and instead provides other programs with solutions to common problems. Why should every programmer waste time re-inventing the wheel, when someone else that's more versed in that has already created a perfect or near-perfect implementation? The Standard Library provides a lot of common things programmers end up needing, and it has the key advantage of not requiring any overhead, as it's included in every JVM.

## Git
- Git is a VCS (Version Control System), which essentially means it's a program that allows you to save checkpoints in your code, to roll it back if something goes wrong; it also has a number of features to deal with concurrent edits (i.e. when you are working on the same program with a team).
- There are some wrappers out there - such as the GitHub application - that simplify its use considerably, but I'll be using plain CLI Git. Why? Because if you learn how to use it properly, you might just figure out how it works. And, of course, there are a number of more advanced uses that are either impractical or straight up impossible in the "simplified" version. If you're stubborn on refusing to learn Git, you *may* use such wrappers, but you're on your own if you can't figure out something. Take shortcuts at your own risk.
- Before we begin, it's important that you configure your git properly. Be very careful in this - improper configuration can result in you doxxing yourself.
    - Set your name and email with `git config --global user.name yourname` and `git config --global user.email youremail`. You don't have to use your real name (and you shouldn't unless you aren't afraid of it being out there), but the email must be valid. Just make sure to use one you're comfortable sharing. If you want to manage multiple identities, there's multiple ways to go about it. I might write up on that in an extra.
    - Run the command `git config --global init.defaultBranch master`. This sets the name of your default branch - we'll see later what it means.
    - Run the command `git config --global push.autoSetupRemote true`. I'll explain later what it does.
- A *repository* is a folder that contains content that may be tracked by git. You can create a repository in a given folder by running the command `git init` within it. It will create a hidden folder called ".git" that will contain its information. For beginner-grade Git use, you don't really need to worry about what's in there. IntelliJ can do this step for you, when you create a new project.
- You may create, in the repository root, a file called ".gitignore", which contains a list of files and folder Git will never attempt to track. This is typically used for files you don't need to share, such as the temporary stuff created by the IDE while building. IntelliJ also creates a default one when configured to initialize a project with a Git repository. There is also a gitignore generator which you can find [here](https://gitignore.io/): you input what you're using (i.e. your IDE, programming language and build system) and it will output a valid gitignore.
- A *commit* is essentially a snapshot of your code. To create one, you first need to tell Git what to track by using the command `git add`. You should "add" any individual file you want Git to track (or you may use `git add *` or `git add .` to add all files in the folder and any subfolder). Then you should write `git commit`. Your editor of choice (which you configured when installing Git) should open, asking you to write a "commit message" - essentially, a little note explaining what you've changed. Writing proper commit messages is very important when working in teams (but also when you're working alone, if your memory isn't that good). You may specify the message directly from the command line, without running the editor, with the `-m` flag, like this: `git commit -m "the message"`. You can also skip adding any file *you've tracked before* by adding the `-a` flag to the commit command. It will automatically "add" all already existing files (this will not work for wholly new files).
- You now have set up a checkpoint, but what good is it if you can't share it with others? I did mention Git was meant to aid working with teams. As such, you need to *push* your repository to a *remote*. There are countless Git hosting services, most famous of which are GitHub and GitLab. We'll use the former, mainly because it's not painfully slow. Register on GitHub if you don't already have an account (make sure to use the same email you set on Gimake sure to use the same email you set on Git), and create a new repository on there. GitHub will give you instructions similar to mine when you have your blank repository set up. The takeaway is the url, which should look something like this: `git@github.com:youraccount/yourrepo.git`. Copy that.
- Run `git remote add origin repolink`, of course replacing repolink with what you just copied. Then, finally, run `git push`. 
    - If you get an error asking you to run the push command again with some flags, you did not set the autoSetupRemote flag. Basically, it's asking you what remote branch matches yours - it doesn't have to have the same name on both sides. But, usually that's what you want, so you're better off just setting the flag to true.
    - If you get an error saying that you don't have access, follow the next section and run the command again.
- When working with a team, you generally don't want to push broken code onto the primary branch (which is usually called `master`Â²). A *branch* is a separate "line" of commits that diverges at a specific point: as the name suggests, think of it like a tree (physical AND mathematical). You can create a new branch with `git checkout -b branchname`, and you can switch between branches with `git checkout branchname`. When you're done working on a branch and are satisfied with the changes, you can *merge* them back into the primary branch. To do so, you *check out* the primary branch, then run the command `git merge branchToMerge`. It will usually work smoothly, but sometimes conflicts may arise. I suggest you read up on the Git docs to see exactly how conflict resultion works. Once the merge is complete, you should *push* the primary branch to make sure the remote repository stores the changes, then you should delete the divergent branch with `git branch -D branchYouMerged` (this only does it locally, sometimes you might have to do so remotely as well with `git push --delete origin branchYouMerged`).

### Further Reading
- Git comes with a pretty massive [reference manual](https://git-scm.com/docs) which you may check at any time if you don't remember how something works.
- If you prefer reading up a bit on how Git works - and also get a better tutorial than I'll be able to give you - check out the [Pro Git book](https://git-scm.com/book/en/v2), specifically sections 2 and 3.

## SSH
- SSH (short for Secure Shell) is a system which enables you to connect remotely to another machine securely, by authenticating you through an SSH key. An SSH key is a crypthgraphic way of verifying one's identity. In its most common implementation - which, incidentally, is what we'll be using - you're going to use the RSA (Rivest-Shamir-Adleman) algorithm to generate two keys: a public one, and a private one. As the names suggest, you'll have to keep one secret, and give the other to anyone who should verify your identity. You shouldn't give out your private key ever, because anyone with that will be able to impersonate you. I'm not going to get in depth about how that works here, just know that there's a mathematical trick to it.
- First off, you must start the SSH agent.
    - If you are on Windows, you'll actually have it easier for a change. Open up the Services menu (which you can find by search or by executing services.msc via Win+R). Find the one whose name starts with OpenSSH, set it to start automatically. And start it manually as well. If the OpenSSH service doesn't show up, follow [this](https://learn.microsoft.com/en-us/windows-server/administration/openssh/openssh_install_firstuse?tabs=gui) guide.
    - If you are on Linux, run `eval $(ssh-agent)`. If you want it to start automatically, you can read up [here](https://wiki.archlinux.org/title/SSH_keys#Start_ssh-agent_with_systemd_user).
- Run `ssh-keygen`. You can use the defaults for everything, but note down the path to your key.
- Run `ssh-add path/to/your/key`. Remember, you should use `/` (slash) on Linux, and `\` (backslash) on Windows.
- Copy the contents of `path/to/your/key.pub` (i.e. a file named just like your key but with a `.pub` extension). On Linux, you could use the `cat` command to print the contents of that file to the console. Regster it on GitHub. You can do so by going in your account settings, in the "SSH and GPG keys" section. Name it whatever you want, paste the key, leave everything else as default.

### Further Reading
- You can read up on RSA in its Wikipedia article, it's actually pretty well explained. Most interesting to you should be the "Key Generation" section. 
- GitHub has a guide on setting up SSH, [here](https://docs.github.com/en/authentication/connecting-to-github-with-ssh).

## IntelliJ
- IntelliJ is an IDE (Integrated Development Environment). You can use whatever IDE you want - you can even code with just Notepad and the terminal if it makes you happy - but that's what I'll be using. IntelliJ's pros: complete, comfortable, has features for collaborative coding. Cons: it's slow as fuck. Like, seriously. Especially with bigger projects. Alternatives: Eclipse (notably, it's the editor of choice of a lot of Minecraft modders) and vim/neovim combined with a Java language server. There's probably more, but that's those I can think of.
- Create a new project. Set whatever name you want, set Gradle as build system, Gradle DSL to Groovy (*sigh*) and leave the rest as is.
- A "build system" is basically a compilation helper. You could feasibly compile all your project with `javac` and the built-in JDK stuff, but you'll hate yourself for doing that and besides nobody actually does that. The "big two" build systems are Maven and Gradle. Maven is "simpler": it's configurable via XML files, and many favor it because of its simplicity. Gradle on the other hand, is configured via scripting - which can be done in Kotlin or Groovy (I'll use Groovy because that's what I learned, back when Kotlin wasn't an option). We'll be using Gradle because it's the most common in the Minecraft modding community, and because it can do everything Maven can do and more. I will NOT cover anytime soon Gradle scripting in detail, for now just know that it's a thing.
- IntelliJ will generate a "Hello World" example program for you. See the next section for details. As for the rest:
- `build.gradle` and `setting.gradle` contain the Gradle configuration. Don't touch it, for now, just know that's where it is.
- `gradlew`, `gradlew.bat` and the `gradle` folder contain the "Gradle wrapper" - essentially a minimised version of Gradle that gets shipped with your project to ensure your build conditions remain the same for anyone cloning your project.
- The `src` folder contains, as you might've guessed, the sources for your program.
    - The folder(s) inside here (by default `main` and `test`) are "modules", a Gradle construct which is actually only used in big projects made up of multiple parts. Don't bother with it for now, just know that the one called `main` is the default one where your code will reside.
    - Inside each module there's one folder for each language in the project - as I mentioned, there are multiple JVM languages that can work with each other - and obviously the one you're interested in is the one called `java`. There's also another folder, called `resources`, which generally contains parts of the project that aren't code - such as images, text files and so on.

### Further Reading
- You can read Gradle's docs [here](https://docs.gradle.org/current/userguide/userguide.html) if you're curious about it.

## Hello World
I'll explain briefly the contents, but it's fine if you don't get most of it. We'll revisit each of these topic in detail in the future. The Hello World should look something like this:

```java
package org.example;

public class Main {
	public static void main(String[] args) {
        	System.out.println("Hello world!");
	}
}
```

- In most cases, to each class corresponds a file: the one you're looking at is called `Main.java`. A `package` is a way to distinguish classes in larger projects even if they happen to have the same name. The package generally corresponds to your class file's path - so the package "org.example" means that your Main class is placed in `src/main/java/org/example/Main.java`.
- Most *classes* are public, and the first line aside from the package is the class' declaration. Generally speaking, class names have the first letter capitalised, and LookLikeThis when their name would be made up of multiple words. We'll see classes more in detail in a later lesson, but for now just know that, in Java, no code can exist outside of a class, so for now think of them as code containers.
- What follows is a *method*, which is basically a set of instructions belonging to a class, but we'll see in the future what it means. `public static void main(String[] args)` is *always* what the "main method" looks like, the "main method" being the one that is executed first, where your porgram starts. I'll explain briefly what it means, but it's okay if you don't get it. We'll see what each of these keywords mean in a later lesson.
    - `public` means that it's accessible from code present in any other class.
    - `static` means it belongs to the class rather than to the object, since it is instantiated immediately; don't worry too much about what this means, for now.
    - `void` means that the method has no return value. Again, don't worry about this for now.
    - `String[] args` are the arguments passed to the method; in this case, they are whatever the user passed from the command line.
- Here comes the part you actually need to get. `System.out.println("your text")` will print anything between quotes to the console, *and* append the newline sequence at the end of your text. The newline character is a sequence that signals to editors that a new line starts, and it's the `\n` ("newline") chracter, commonly referred to as "LF", on Mac and Linux and `\r\n` ("carriage return" and "newline"), commonly referred to as "CRLF", on WindowsÂ³.
- If you don't want to print the newline character, use `System.out.print("your text")` instead. I invite you to try chaining multiple of these instructions to notice the difference, if you don't get it.
- In Java every *statement* ends with a semicolon.

## Notes
Â¹Although Scala and Kotlin are both fairly good languages design-wise and fully compatible with Java, I frankly think that they are akin to trying to cure cancer with a band-aid. The "first class citizen" of the JVM is and always will be Java. Any new feature will be implemented into Java first, and the virtual machine's CPU is designed to serve Java's needs and resembles the Java way of thinking. So, that's why I think Java is *still* a better option, for all its flaws. And, frankly, if your aim was to write fast and memory-safe code, what you should actually do is uninstall anything remotely related to the JVM and learn Rust instead.

Â²There's a bit of a debate over what it should be. `master` is the historical one, but in the past few years there's been people (morons) claiming that it's racist and should be changed. GitHub of course rushed to change it to `main`, breaking a standard and creating countless inconsistencies. I believe they also went back on their change later on, but I don't know for sure and don't care. It really doesn't matter what you name it, but I'll be assuming you use `master`.

Â³This difference is due to design choices. Mac and Linux both are "Unix-like" operating systems, meaning that they largely adopt the design philosophies of the Unix operating system, originally developed way back in the 70s. Windows, on the other hand, descends from DOS, which in turn adopted `\r\n` as a way to maintain compatibility with an earlier microcomputer OS, called CP/M (short for "Control Program/Monitor").
